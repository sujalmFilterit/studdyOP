================================================================================
HOW THE BACKEND IS CONFIGURED FOR SERVERLESS (VERCEL)
================================================================================

The backend is set up to work as a serverless function on Vercel, which means:
- NO app.listen() in production
- NO port binding
- Runs as individual function invocations
- Each request triggers a new function instance

================================================================================
KEY FILES AND CONFIGURATION
================================================================================

1. api/index.js (Serverless Function Wrapper)
   -------------------------------------------
   This file wraps the Express app for Vercel serverless functions.
   
   Code:
   import app from '../src/index.js';
   export default (req, res) => {
     return app(req, res);
   };
   
   What it does:
   - Exports the Express app as a serverless function handler
   - Vercel calls this function for each HTTP request
   - No server needs to be running - Vercel handles that

2. vercel.json (Vercel Configuration)
   -----------------------------------
   {
     "version": 2,
     "builds": [
       {
         "src": "api/index.js",
         "use": "@vercel/node"
       }
     ],
     "routes": [
       {
         "src": "/(.*)",
         "dest": "/api/index.js"
       }
     ]
   }
   
   What it does:
   - Tells Vercel to use Node.js runtime
   - Routes all requests to api/index.js
   - Builds the serverless function

3. src/index.js (Main Express App)
   ---------------------------------
   Key parts:
   
   a) NO app.listen() in Vercel environment:
      if (process.env.VERCEL !== '1') {
        app.listen(PORT, () => {
          console.log(`Server running on http://localhost:${PORT}`);
        });
      }
      
      What this does:
      - Only starts a server if NOT running on Vercel
      - In Vercel, process.env.VERCEL === '1'
      - So app.listen() is skipped in production
      - The server is handled by Vercel's infrastructure
   
   b) MongoDB Connection (Serverless-friendly):
      if (mongoose.connection.readyState === 0) {
        mongoose.connect(MONGO_URI, {
          serverSelectionTimeoutMS: 5000,
          socketTimeoutMS: 45000,
          maxPoolSize: 10,
        })
      }
      
      What this does:
      - Checks if connection already exists (reuses in serverless)
      - Mongoose caches connections automatically
      - Each function invocation can reuse existing connection
      - Prevents creating new connections on every request
   
   c) Export the app:
      export default app;
      
      What this does:
      - Exports Express app so api/index.js can import it
      - Makes the app available as a serverless function

================================================================================
HOW IT WORKS
================================================================================

LOCAL DEVELOPMENT:
------------------
1. You run: npm start
2. process.env.VERCEL is NOT set
3. app.listen() runs
4. Server starts on port 4000 (or PORT env variable)
5. You access: http://localhost:4000

VERCEL PRODUCTION:
------------------
1. Vercel receives HTTP request
2. Vercel calls api/index.js function
3. api/index.js imports src/index.js
4. Express app handles the request
5. Response is sent back
6. Function instance may be kept warm for reuse
7. NO server running - each request is a function invocation

================================================================================
KEY DIFFERENCES: TRADITIONAL vs SERVERLESS
================================================================================

TRADITIONAL SERVER:
- app.listen(PORT) - starts server
- Server runs continuously
- Handles multiple requests on same process
- You manage the server lifecycle

SERVERLESS (VERCEL):
- NO app.listen() - Vercel handles it
- Function invoked per request (or kept warm)
- Each request may use a new function instance
- Vercel manages the lifecycle
- Auto-scales based on traffic

================================================================================
ENVIRONMENT VARIABLES
================================================================================

Required for serverless:
- MONGO_URI: MongoDB Atlas connection string
- HF_TOKEN: HuggingFace API token
- JWT_SECRET: JWT signing secret
- NODE_ENV: Set to "production" on Vercel
- VERCEL: Automatically set to "1" by Vercel

================================================================================
IMPORTANT NOTES
================================================================================

1. Connection Pooling:
   - MongoDB connections are cached/reused
   - Mongoose handles this automatically
   - Prevents connection exhaustion

2. Cold Starts:
   - First request may be slower (function initialization)
   - Subsequent requests are faster (warm function)
   - Vercel keeps functions warm for active deployments

3. Timeout Limits:
   - Vercel Hobby plan: 10 seconds per function
   - Pro plan: 60 seconds
   - Plan accordingly for long-running AI requests

4. Stateless:
   - Each function invocation is independent
   - Don't rely on in-memory state between requests
   - Use database for persistent data

5. File System:
   - Read-only in serverless (except /tmp)
   - Don't write files to disk
   - Use external storage (MongoDB, S3, etc.)

================================================================================
TESTING LOCALLY
================================================================================

To test serverless behavior locally:
1. Set VERCEL=1 in your .env file
2. Run: npm start
3. Server won't start (no app.listen())
4. Use Vercel CLI: vercel dev (simulates serverless)

To test as traditional server:
1. Don't set VERCEL env variable
2. Run: npm start
3. Server starts normally on port 4000

================================================================================
DEPLOYMENT FLOW
================================================================================

1. Push code to GitHub
2. Vercel detects push
3. Vercel runs build (npm install)
4. Vercel packages api/index.js as serverless function
5. Function is deployed
6. All routes accessible at: https://your-project.vercel.app/api/...
7. Vercel handles scaling, routing, and execution

================================================================================
SUMMARY
================================================================================

The backend works as serverless by:
✓ Exporting Express app (not starting a server)
✓ Using api/index.js as Vercel function wrapper
✓ Checking process.env.VERCEL to skip app.listen()
✓ Reusing MongoDB connections (serverless-friendly)
✓ Stateless design (no in-memory state)

This allows the same codebase to work:
- As traditional server (local development)
- As serverless function (Vercel production)

No code changes needed - just environment detection!

